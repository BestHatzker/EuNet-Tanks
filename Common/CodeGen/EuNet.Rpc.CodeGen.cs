// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by EuNet.CodeGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading.Tasks;
using EuNet.Core;
using EuNet.Rpc;
#if UNITY_EDITOR || UNITY_STANDALONE || UNITY_ANDROID || UNITY_IOS
using EuNet.Unity;
using UnityEngine;
#endif

#region Common.IGameCsRpc

namespace Common
{
    public interface IGameCsRpc_NoReply
    {
        void GetUserInfo(string name);
        void Login(int version, string id, string authKey);
        void QuickJoinRoom(Common.GameMode gameMode);
    }

    public enum IGameCsRpc_Enum : int
    {
        GetUserInfo = -2085143856,
        Login = -1840948958,
        QuickJoinRoom = -753509775,
    }

    public class GameCsRpc : RpcRequester, IGameCsRpc, IGameCsRpc_NoReply
    {
        public override Type InterfaceType => typeof(IGameCsRpc);

        public GameCsRpc() : base(null)
        {
            DeliveryMethod = DeliveryMethod.Tcp;
        }

        public GameCsRpc(ISession target) : base(target)
        {
            DeliveryMethod = DeliveryMethod.Tcp;
        }

        public GameCsRpc(ISession target, IRequestWaiter requestWaiter, TimeSpan? timeout = null) : base(target, requestWaiter, timeout)
        {
            DeliveryMethod = DeliveryMethod.Tcp;
        }

        public IGameCsRpc_NoReply WithNoReply()
        {
            return this;
        }

        public GameCsRpc WithRequestWaiter(IRequestWaiter requestWaiter)
        {
            return new GameCsRpc(Target, requestWaiter, Timeout);
        }

        public GameCsRpc WithTimeout(TimeSpan? timeout)
        {
            return new GameCsRpc(Target, RequestWaiter, timeout);
        }

        public async Task<Common.UserInfo> GetUserInfo(string name)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameCsRpc_Enum.GetUserInfo);
                _writer_.Write(name);
                using(var _reader_ = await SendRequestAndReceive(_writer_))
                {
                    return NetDataSerializer.Deserialize<Common.UserInfo>(_reader_);
                }
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        public async Task<int> Login(int version, string id, string authKey)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameCsRpc_Enum.Login);
                _writer_.Write(version);
                _writer_.Write(id);
                _writer_.Write(authKey);
                using(var _reader_ = await SendRequestAndReceive(_writer_))
                {
                    return _reader_.ReadInt32();
                }
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        public async Task<bool> QuickJoinRoom(Common.GameMode gameMode)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameCsRpc_Enum.QuickJoinRoom);
                NetDataSerializer.Serialize<Common.GameMode>(_writer_, gameMode);
                using(var _reader_ = await SendRequestAndReceive(_writer_))
                {
                    return _reader_.ReadBoolean();
                }
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IGameCsRpc_NoReply.GetUserInfo(string name)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameCsRpc_Enum.GetUserInfo);
                _writer_.Write(name);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IGameCsRpc_NoReply.Login(int version, string id, string authKey)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameCsRpc_Enum.Login);
                _writer_.Write(version);
                _writer_.Write(id);
                _writer_.Write(authKey);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IGameCsRpc_NoReply.QuickJoinRoom(Common.GameMode gameMode)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameCsRpc_Enum.QuickJoinRoom);
                NetDataSerializer.Serialize<Common.GameMode>(_writer_, gameMode);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }
    }

    public abstract class GameCsRpcServiceAbstract : IRpcInvokable, IGameCsRpc
    {
        public abstract Task<Common.UserInfo> GetUserInfo(string name);
        public abstract Task<int> Login(int version, string id, string authKey);
        public abstract Task<bool> QuickJoinRoom(Common.GameMode gameMode);
        public async Task<bool> Invoke(object _target_, NetDataReader _reader_, NetDataWriter _writer_)
        {
            ISession session = _target_ as ISession;
            var typeEnum = (IGameCsRpc_Enum)_reader_.ReadInt32();
            switch(typeEnum)
            {
                case IGameCsRpc_Enum.GetUserInfo:
                    {
                        var name = _reader_.ReadString();
                        var _result_ = await GetUserInfo(name);
                        NetDataSerializer.Serialize<Common.UserInfo>(_writer_, _result_);
                    }
                    break;
                case IGameCsRpc_Enum.Login:
                    {
                        var version = _reader_.ReadInt32();
                        var id = _reader_.ReadString();
                        var authKey = _reader_.ReadString();
                        var _result_ = await Login(version, id, authKey);
                        _writer_.Write(_result_);
                    }
                    break;
                case IGameCsRpc_Enum.QuickJoinRoom:
                    {
                        var gameMode = NetDataSerializer.Deserialize<Common.GameMode>(_reader_);
                        var _result_ = await QuickJoinRoom(gameMode);
                        _writer_.Write(_result_);
                    }
                    break;
                default: return false;
            }

            return true;
        }
    }

    public class GameCsRpcServiceSession : IRpcInvokable
    {
        public async Task<bool> Invoke(object _target_, NetDataReader _reader_, NetDataWriter _writer_)
        {
            ISession session = _target_ as ISession;
            var typeEnum = (IGameCsRpc_Enum)_reader_.ReadInt32();
            switch(typeEnum)
            {
                case IGameCsRpc_Enum.GetUserInfo:
                    {
                        var name = _reader_.ReadString();
                        var _result_ = await (session as IGameCsRpc).GetUserInfo(name);
                        NetDataSerializer.Serialize<Common.UserInfo>(_writer_, _result_);
                    }
                    break;
                case IGameCsRpc_Enum.Login:
                    {
                        var version = _reader_.ReadInt32();
                        var id = _reader_.ReadString();
                        var authKey = _reader_.ReadString();
                        var _result_ = await (session as IGameCsRpc).Login(version, id, authKey);
                        _writer_.Write(_result_);
                    }
                    break;
                case IGameCsRpc_Enum.QuickJoinRoom:
                    {
                        var gameMode = NetDataSerializer.Deserialize<Common.GameMode>(_reader_);
                        var _result_ = await (session as IGameCsRpc).QuickJoinRoom(gameMode);
                        _writer_.Write(_result_);
                    }
                    break;
                default: return false;
            }

            return true;
        }
    }
}

#endregion
#region Common.IGameScRpc

namespace Common
{
    public interface IGameScRpc_NoReply
    {
        void OnCreateRoom(Common.RoomInfo roomInfo);
        void OnJoinRoom(Common.RoomInfo roomInfo);
        void OnJoinRoomOtherUser(Common.RoomSlotInfo roomSlotInfo);
        void OnLeaveRoom(int roomId);
        void OnLeaveRoomOtherUser(int roomId, byte slotId, ushort sessionId);
    }

    public enum IGameScRpc_Enum : int
    {
        OnCreateRoom = -1761227123,
        OnJoinRoom = -1021284175,
        OnJoinRoomOtherUser = -131055536,
        OnLeaveRoom = -861361324,
        OnLeaveRoomOtherUser = -1303109037,
    }

    public class GameScRpc : RpcRequester, IGameScRpc, IGameScRpc_NoReply
    {
        public override Type InterfaceType => typeof(IGameScRpc);

        public GameScRpc() : base(null)
        {
            DeliveryMethod = DeliveryMethod.Tcp;
        }

        public GameScRpc(ISession target) : base(target)
        {
            DeliveryMethod = DeliveryMethod.Tcp;
        }

        public GameScRpc(ISession target, IRequestWaiter requestWaiter, TimeSpan? timeout = null) : base(target, requestWaiter, timeout)
        {
            DeliveryMethod = DeliveryMethod.Tcp;
        }

        public IGameScRpc_NoReply WithNoReply()
        {
            return this;
        }

        public GameScRpc WithRequestWaiter(IRequestWaiter requestWaiter)
        {
            return new GameScRpc(Target, requestWaiter, Timeout);
        }

        public GameScRpc WithTimeout(TimeSpan? timeout)
        {
            return new GameScRpc(Target, RequestWaiter, timeout);
        }

        public async Task OnCreateRoom(Common.RoomInfo roomInfo)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnCreateRoom);
                NetDataSerializer.Serialize<Common.RoomInfo>(_writer_, roomInfo);
                await SendRequestAndWait(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        public async Task OnJoinRoom(Common.RoomInfo roomInfo)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnJoinRoom);
                NetDataSerializer.Serialize<Common.RoomInfo>(_writer_, roomInfo);
                await SendRequestAndWait(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        public async Task OnJoinRoomOtherUser(Common.RoomSlotInfo roomSlotInfo)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnJoinRoomOtherUser);
                NetDataSerializer.Serialize<Common.RoomSlotInfo>(_writer_, roomSlotInfo);
                await SendRequestAndWait(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        public async Task OnLeaveRoom(int roomId)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnLeaveRoom);
                _writer_.Write(roomId);
                await SendRequestAndWait(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        public async Task OnLeaveRoomOtherUser(int roomId, byte slotId, ushort sessionId)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnLeaveRoomOtherUser);
                _writer_.Write(roomId);
                _writer_.Write(slotId);
                _writer_.Write(sessionId);
                await SendRequestAndWait(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IGameScRpc_NoReply.OnCreateRoom(Common.RoomInfo roomInfo)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnCreateRoom);
                NetDataSerializer.Serialize<Common.RoomInfo>(_writer_, roomInfo);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IGameScRpc_NoReply.OnJoinRoom(Common.RoomInfo roomInfo)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnJoinRoom);
                NetDataSerializer.Serialize<Common.RoomInfo>(_writer_, roomInfo);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IGameScRpc_NoReply.OnJoinRoomOtherUser(Common.RoomSlotInfo roomSlotInfo)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnJoinRoomOtherUser);
                NetDataSerializer.Serialize<Common.RoomSlotInfo>(_writer_, roomSlotInfo);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IGameScRpc_NoReply.OnLeaveRoom(int roomId)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnLeaveRoom);
                _writer_.Write(roomId);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IGameScRpc_NoReply.OnLeaveRoomOtherUser(int roomId, byte slotId, ushort sessionId)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameScRpc_Enum.OnLeaveRoomOtherUser);
                _writer_.Write(roomId);
                _writer_.Write(slotId);
                _writer_.Write(sessionId);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }
    }

    public abstract class GameScRpcServiceAbstract : IRpcInvokable, IGameScRpc
    {
        public abstract Task OnCreateRoom(Common.RoomInfo roomInfo);
        public abstract Task OnJoinRoom(Common.RoomInfo roomInfo);
        public abstract Task OnJoinRoomOtherUser(Common.RoomSlotInfo roomSlotInfo);
        public abstract Task OnLeaveRoom(int roomId);
        public abstract Task OnLeaveRoomOtherUser(int roomId, byte slotId, ushort sessionId);
        public async Task<bool> Invoke(object _target_, NetDataReader _reader_, NetDataWriter _writer_)
        {
            ISession session = _target_ as ISession;
            var typeEnum = (IGameScRpc_Enum)_reader_.ReadInt32();
            switch(typeEnum)
            {
                case IGameScRpc_Enum.OnCreateRoom:
                    {
                        var roomInfo = NetDataSerializer.Deserialize<Common.RoomInfo>(_reader_);
                        await OnCreateRoom(roomInfo);
                    }
                    break;
                case IGameScRpc_Enum.OnJoinRoom:
                    {
                        var roomInfo = NetDataSerializer.Deserialize<Common.RoomInfo>(_reader_);
                        await OnJoinRoom(roomInfo);
                    }
                    break;
                case IGameScRpc_Enum.OnJoinRoomOtherUser:
                    {
                        var roomSlotInfo = NetDataSerializer.Deserialize<Common.RoomSlotInfo>(_reader_);
                        await OnJoinRoomOtherUser(roomSlotInfo);
                    }
                    break;
                case IGameScRpc_Enum.OnLeaveRoom:
                    {
                        var roomId = _reader_.ReadInt32();
                        await OnLeaveRoom(roomId);
                    }
                    break;
                case IGameScRpc_Enum.OnLeaveRoomOtherUser:
                    {
                        var roomId = _reader_.ReadInt32();
                        var slotId = _reader_.ReadByte();
                        var sessionId = _reader_.ReadUInt16();
                        await OnLeaveRoomOtherUser(roomId, slotId, sessionId);
                    }
                    break;
                default: return false;
            }

            return true;
        }
    }

    public class GameScRpcServiceSession : IRpcInvokable
    {
        public async Task<bool> Invoke(object _target_, NetDataReader _reader_, NetDataWriter _writer_)
        {
            ISession session = _target_ as ISession;
            var typeEnum = (IGameScRpc_Enum)_reader_.ReadInt32();
            switch(typeEnum)
            {
                case IGameScRpc_Enum.OnCreateRoom:
                    {
                        var roomInfo = NetDataSerializer.Deserialize<Common.RoomInfo>(_reader_);
                        await (session as IGameScRpc).OnCreateRoom(roomInfo);
                    }
                    break;
                case IGameScRpc_Enum.OnJoinRoom:
                    {
                        var roomInfo = NetDataSerializer.Deserialize<Common.RoomInfo>(_reader_);
                        await (session as IGameScRpc).OnJoinRoom(roomInfo);
                    }
                    break;
                case IGameScRpc_Enum.OnJoinRoomOtherUser:
                    {
                        var roomSlotInfo = NetDataSerializer.Deserialize<Common.RoomSlotInfo>(_reader_);
                        await (session as IGameScRpc).OnJoinRoomOtherUser(roomSlotInfo);
                    }
                    break;
                case IGameScRpc_Enum.OnLeaveRoom:
                    {
                        var roomId = _reader_.ReadInt32();
                        await (session as IGameScRpc).OnLeaveRoom(roomId);
                    }
                    break;
                case IGameScRpc_Enum.OnLeaveRoomOtherUser:
                    {
                        var roomId = _reader_.ReadInt32();
                        var slotId = _reader_.ReadByte();
                        var sessionId = _reader_.ReadUInt16();
                        await (session as IGameScRpc).OnLeaveRoomOtherUser(roomId, slotId, sessionId);
                    }
                    break;
                default: return false;
            }

            return true;
        }
    }
}

#endregion
#region Common.IActorRpc
#if UNITY_EDITOR || UNITY_STANDALONE || UNITY_ANDROID || UNITY_IOS

namespace Common
{
    public interface IActorRpc_NoReply
    {
        void OnDamage(float damage, float currentHp);
        void OnFire(string shellResource, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Vector3 velocity);
        void OnMove(float move, float turn, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation);
    }

    public enum IActorRpc_Enum : int
    {
        OnDamage = -539305514,
        OnFire = -1651121265,
        OnMove = -1651379490,
    }

    public class ActorRpc : RpcRequester, IActorRpc, IActorRpc_NoReply
    {
        public override Type InterfaceType => typeof(IActorRpc);

        public ActorRpc(NetView view, TimeSpan? timeout = null)
            	: base(NetClientGlobal.Instance.Client, new NetViewRequestWaiter(view), timeout)
        {
            DeliveryMethod = DeliveryMethod.Unreliable;
            DeliveryTarget = DeliveryTarget.Others;
        }

        public ActorRpc(ISession target, IRequestWaiter requestWaiter, TimeSpan? timeout = null) : base(target, requestWaiter, timeout)
        {
            DeliveryMethod = DeliveryMethod.Unreliable;
            DeliveryTarget = DeliveryTarget.Others;
        }

        public ActorRpc ToTarget(DeliveryMethod deliveryMethod, ushort sessionId)
        {
            DeliveryMethod = deliveryMethod;
            DeliveryTarget = DeliveryTarget.Target;
            Extra = sessionId;
            return this;
        }

        public ActorRpc ToMaster(DeliveryMethod deliveryMethod)
        {
            DeliveryMethod = deliveryMethod;
            DeliveryTarget = DeliveryTarget.Master;
            return this;
        }

        public IActorRpc_NoReply ToOthers(DeliveryMethod deliveryMethod)
        {
            DeliveryMethod = deliveryMethod;
            DeliveryTarget = DeliveryTarget.Others;
            return this;
        }

        public IActorRpc_NoReply ToAll(DeliveryMethod deliveryMethod)
        {
            DeliveryMethod = deliveryMethod;
            DeliveryTarget = DeliveryTarget.All;
            return this;
        }

        public IActorRpc_NoReply WithNoReply()
        {
            return this;
        }

        public ActorRpc WithRequestWaiter(IRequestWaiter requestWaiter)
        {
            return new ActorRpc(Target, requestWaiter, Timeout);
        }

        public ActorRpc WithTimeout(TimeSpan? timeout)
        {
            return new ActorRpc(Target, RequestWaiter, timeout);
        }

        public async Task OnDamage(float damage, float currentHp)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IActorRpc_Enum.OnDamage);
                _writer_.Write(damage);
                _writer_.Write(currentHp);
                await SendRequestAndWait(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        public async Task OnFire(string shellResource, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Vector3 velocity)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IActorRpc_Enum.OnFire);
                _writer_.Write(shellResource);
                _writer_.Write(position);
                _writer_.Write(rotation);
                _writer_.Write(velocity);
                await SendRequestAndWait(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        public async Task OnMove(float move, float turn, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IActorRpc_Enum.OnMove);
                _writer_.Write(move);
                _writer_.Write(turn);
                _writer_.Write(position);
                _writer_.Write(rotation);
                await SendRequestAndWait(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IActorRpc_NoReply.OnDamage(float damage, float currentHp)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IActorRpc_Enum.OnDamage);
                _writer_.Write(damage);
                _writer_.Write(currentHp);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IActorRpc_NoReply.OnFire(string shellResource, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Vector3 velocity)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IActorRpc_Enum.OnFire);
                _writer_.Write(shellResource);
                _writer_.Write(position);
                _writer_.Write(rotation);
                _writer_.Write(velocity);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IActorRpc_NoReply.OnMove(float move, float turn, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IActorRpc_Enum.OnMove);
                _writer_.Write(move);
                _writer_.Write(turn);
                _writer_.Write(position);
                _writer_.Write(rotation);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }
    }

    [RequireComponent(typeof(NetView))]
    public abstract class ActorRpcServiceBehaviour : MonoBehaviour, IRpcInvokable, IActorRpc
    {
        public abstract Task OnDamage(float damage, float currentHp);
        public abstract Task OnFire(string shellResource, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Vector3 velocity);
        public abstract Task OnMove(float move, float turn, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation);
        public async Task<bool> Invoke(object _target_, NetDataReader _reader_, NetDataWriter _writer_)
        {
            ISession session = _target_ as ISession;
            var typeEnum = (IActorRpc_Enum)_reader_.ReadInt32();
            switch(typeEnum)
            {
                case IActorRpc_Enum.OnDamage:
                    {
                        var damage = _reader_.ReadSingle();
                        var currentHp = _reader_.ReadSingle();
                        await OnDamage(damage, currentHp);
                    }
                    break;
                case IActorRpc_Enum.OnFire:
                    {
                        var shellResource = _reader_.ReadString();
                        var position = _reader_.ReadVector3();
                        var rotation = _reader_.ReadQuaternion();
                        var velocity = _reader_.ReadVector3();
                        await OnFire(shellResource, position, rotation, velocity);
                    }
                    break;
                case IActorRpc_Enum.OnMove:
                    {
                        var move = _reader_.ReadSingle();
                        var turn = _reader_.ReadSingle();
                        var position = _reader_.ReadVector3();
                        var rotation = _reader_.ReadQuaternion();
                        await OnMove(move, turn, position, rotation);
                    }
                    break;
                default: return false;
            }

            return true;
        }
    }

    public class ActorRpcServiceView : IRpcInvokable
    {
        public async Task<bool> Invoke(object _target_, NetDataReader _reader_, NetDataWriter _writer_)
        {
            NetView _view_ = _target_ as NetView;
            var typeEnum = (IActorRpc_Enum)_reader_.ReadInt32();
            switch(typeEnum)
            {
                case IActorRpc_Enum.OnDamage:
                    {
                        var damage = _reader_.ReadSingle();
                        var currentHp = _reader_.ReadSingle();
                        await _view_.FindRpcHandler<IActorRpc>().OnDamage(damage, currentHp);
                    }
                    break;
                case IActorRpc_Enum.OnFire:
                    {
                        var shellResource = _reader_.ReadString();
                        var position = _reader_.ReadVector3();
                        var rotation = _reader_.ReadQuaternion();
                        var velocity = _reader_.ReadVector3();
                        await _view_.FindRpcHandler<IActorRpc>().OnFire(shellResource, position, rotation, velocity);
                    }
                    break;
                case IActorRpc_Enum.OnMove:
                    {
                        var move = _reader_.ReadSingle();
                        var turn = _reader_.ReadSingle();
                        var position = _reader_.ReadVector3();
                        var rotation = _reader_.ReadQuaternion();
                        await _view_.FindRpcHandler<IActorRpc>().OnMove(move, turn, position, rotation);
                    }
                    break;
                default: return false;
            }

            return true;
        }
    }
}

#endif
#endregion
#region Common.IGameManagerRpc
#if UNITY_EDITOR || UNITY_STANDALONE || UNITY_ANDROID || UNITY_IOS

namespace Common
{
    public interface IGameManagerRpc_NoReply
    {
        void OnRespawn(int viewId, UnityEngine.Vector3 position);
    }

    public enum IGameManagerRpc_Enum : int
    {
        OnRespawn = -449410311,
    }

    public class GameManagerRpc : RpcRequester, IGameManagerRpc, IGameManagerRpc_NoReply
    {
        public override Type InterfaceType => typeof(IGameManagerRpc);

        public GameManagerRpc(NetView view, TimeSpan? timeout = null)
            	: base(NetClientGlobal.Instance.Client, new NetViewRequestWaiter(view), timeout)
        {
            DeliveryMethod = DeliveryMethod.Unreliable;
            DeliveryTarget = DeliveryTarget.Others;
        }

        public GameManagerRpc(ISession target, IRequestWaiter requestWaiter, TimeSpan? timeout = null) : base(target, requestWaiter, timeout)
        {
            DeliveryMethod = DeliveryMethod.Unreliable;
            DeliveryTarget = DeliveryTarget.Others;
        }

        public GameManagerRpc ToTarget(DeliveryMethod deliveryMethod, ushort sessionId)
        {
            DeliveryMethod = deliveryMethod;
            DeliveryTarget = DeliveryTarget.Target;
            Extra = sessionId;
            return this;
        }

        public GameManagerRpc ToMaster(DeliveryMethod deliveryMethod)
        {
            DeliveryMethod = deliveryMethod;
            DeliveryTarget = DeliveryTarget.Master;
            return this;
        }

        public IGameManagerRpc_NoReply ToOthers(DeliveryMethod deliveryMethod)
        {
            DeliveryMethod = deliveryMethod;
            DeliveryTarget = DeliveryTarget.Others;
            return this;
        }

        public IGameManagerRpc_NoReply ToAll(DeliveryMethod deliveryMethod)
        {
            DeliveryMethod = deliveryMethod;
            DeliveryTarget = DeliveryTarget.All;
            return this;
        }

        public IGameManagerRpc_NoReply WithNoReply()
        {
            return this;
        }

        public GameManagerRpc WithRequestWaiter(IRequestWaiter requestWaiter)
        {
            return new GameManagerRpc(Target, requestWaiter, Timeout);
        }

        public GameManagerRpc WithTimeout(TimeSpan? timeout)
        {
            return new GameManagerRpc(Target, RequestWaiter, timeout);
        }

        public async Task OnRespawn(int viewId, UnityEngine.Vector3 position)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameManagerRpc_Enum.OnRespawn);
                _writer_.Write(viewId);
                _writer_.Write(position);
                await SendRequestAndWait(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }

        void IGameManagerRpc_NoReply.OnRespawn(int viewId, UnityEngine.Vector3 position)
        {
            var _writer_ = NetPool.DataWriterPool.Alloc();
            try
            {
                _writer_.Write((int)IGameManagerRpc_Enum.OnRespawn);
                _writer_.Write(viewId);
                _writer_.Write(position);
                SendRequest(_writer_);
            }
            finally
            {
                NetPool.DataWriterPool.Free(_writer_);
            }
        }
    }

    [RequireComponent(typeof(NetView))]
    public abstract class GameManagerRpcServiceBehaviour : MonoBehaviour, IRpcInvokable, IGameManagerRpc
    {
        public abstract Task OnRespawn(int viewId, UnityEngine.Vector3 position);
        public async Task<bool> Invoke(object _target_, NetDataReader _reader_, NetDataWriter _writer_)
        {
            ISession session = _target_ as ISession;
            var typeEnum = (IGameManagerRpc_Enum)_reader_.ReadInt32();
            switch(typeEnum)
            {
                case IGameManagerRpc_Enum.OnRespawn:
                    {
                        var viewId = _reader_.ReadInt32();
                        var position = _reader_.ReadVector3();
                        await OnRespawn(viewId, position);
                    }
                    break;
                default: return false;
            }

            return true;
        }
    }

    public class GameManagerRpcServiceView : IRpcInvokable
    {
        public async Task<bool> Invoke(object _target_, NetDataReader _reader_, NetDataWriter _writer_)
        {
            NetView _view_ = _target_ as NetView;
            var typeEnum = (IGameManagerRpc_Enum)_reader_.ReadInt32();
            switch(typeEnum)
            {
                case IGameManagerRpc_Enum.OnRespawn:
                    {
                        var viewId = _reader_.ReadInt32();
                        var position = _reader_.ReadVector3();
                        await _view_.FindRpcHandler<IGameManagerRpc>().OnRespawn(viewId, position);
                    }
                    break;
                default: return false;
            }

            return true;
        }
    }
}

#endif
#endregion
#region Common

namespace Common
{
    public static class RpcEnumHelper
    {
        public static string GetEnumName(int rpcNameHash)
        {
            switch(rpcNameHash)
            {
                case -2085143856: return "IGameCsRpc.GetUserInfo";
                case -1840948958: return "IGameCsRpc.Login";
                case -753509775: return "IGameCsRpc.QuickJoinRoom";
                case -1761227123: return "IGameScRpc.OnCreateRoom";
                case -1021284175: return "IGameScRpc.OnJoinRoom";
                case -131055536: return "IGameScRpc.OnJoinRoomOtherUser";
                case -861361324: return "IGameScRpc.OnLeaveRoom";
                case -1303109037: return "IGameScRpc.OnLeaveRoomOtherUser";
                case -539305514: return "IActorRpc.OnDamage";
                case -1651121265: return "IActorRpc.OnFire";
                case -1651379490: return "IActorRpc.OnMove";
                case -449410311: return "IGameManagerRpc.OnRespawn";
            }

            return string.Empty;
        }
    }
}

#endregion
#region AOT

namespace AOT
{
    public sealed class AotCodeCommon
    {
        private void UsedOnlyForAOTCodeGeneration()
        {
            new GenericEnumFormatter<Common.GameMode>();
            
            throw new InvalidOperationException("This method is used for AOT code generation only.Do not call it at runtime.");
        }
    }
}

#endregion
#region Common.RoomInfo

namespace Common
{
    public sealed class RoomInfoFormatter : INetDataFormatter<RoomInfo>
    {
        public static readonly RoomInfoFormatter Instance = new RoomInfoFormatter();

        public void Serialize(NetDataWriter _writer_, RoomInfo _value_, NetDataSerializerOptions options)
        {
            NetDataSerializer.Serialize<Common.GameMode>(_writer_, _value_.GameMode);
            NetDataSerializer.Serialize<System.Collections.Generic.List<Common.RoomSlotInfo>>(_writer_, _value_.Slots);
            _writer_.Write(_value_.Id);
        }

        public RoomInfo Deserialize(NetDataReader _reader_, NetDataSerializerOptions options)
        {
            var __GameMode = NetDataSerializer.Deserialize<Common.GameMode>(_reader_);
            var __Slots = NetDataSerializer.Deserialize<System.Collections.Generic.List<Common.RoomSlotInfo>>(_reader_);
            var __Id = _reader_.ReadInt32();

            return new RoomInfo() {
                GameMode = __GameMode,
                Slots = __Slots,
                Id = __Id,
            };
        }
    }
}

#endregion
#region Common.RoomSlotInfo

namespace Common
{
    public sealed class RoomSlotInfoFormatter : INetDataFormatter<RoomSlotInfo>
    {
        public static readonly RoomSlotInfoFormatter Instance = new RoomSlotInfoFormatter();

        public void Serialize(NetDataWriter _writer_, RoomSlotInfo _value_, NetDataSerializerOptions options)
        {
            _writer_.Write(_value_.Name);
            _writer_.Write(_value_.UserId);
            _writer_.Write(_value_.SlotId);
            _writer_.Write(_value_.SessionId);
        }

        public RoomSlotInfo Deserialize(NetDataReader _reader_, NetDataSerializerOptions options)
        {
            var __Name = _reader_.ReadString();
            var __UserId = _reader_.ReadInt64();
            var __SlotId = _reader_.ReadByte();
            var __SessionId = _reader_.ReadUInt16();

            return new RoomSlotInfo() {
                Name = __Name,
                UserId = __UserId,
                SlotId = __SlotId,
                SessionId = __SessionId,
            };
        }
    }
}

#endregion
#region Common.UserInfo

namespace Common
{
    public sealed class UserInfoFormatter : INetDataFormatter<UserInfo>
    {
        public static readonly UserInfoFormatter Instance = new UserInfoFormatter();

        public void Serialize(NetDataWriter _writer_, UserInfo _value_, NetDataSerializerOptions options)
        {
            _writer_.Write(_value_.Name);
            _writer_.Write(_value_.Id);
        }

        public UserInfo Deserialize(NetDataReader _reader_, NetDataSerializerOptions options)
        {
            var __Name = _reader_.ReadString();
            var __Id = _reader_.ReadInt64();

            return new UserInfo() {
                Name = __Name,
                Id = __Id,
            };
        }
    }
}

#endregion
#region CommonResolvers

namespace CommonResolvers
{
    public sealed class GeneratedResolver : INetDataFormatterResolver
    {
        public static readonly GeneratedResolver Instance = new GeneratedResolver();

        private GeneratedResolver()
        {
        }

        public INetDataFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly INetDataFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (INetDataFormatter<T>)GeneratedResolverGetFormatterHelper.GetFormatter(typeof(T));
            }
        }
    }

    internal static class GeneratedResolverGetFormatterHelper
    {
        private static readonly Dictionary<Type, object> FormatterMap = new Dictionary<Type, object>() {
            { typeof(Common.RoomInfo) , Common.RoomInfoFormatter.Instance },
            { typeof(Common.RoomSlotInfo) , Common.RoomSlotInfoFormatter.Instance },
            { typeof(Common.UserInfo) , Common.UserInfoFormatter.Instance },
        };
        internal static object GetFormatter(Type t)
        {
            TypeInfo ti = t.GetTypeInfo();
            if (ti.IsGenericType)
            {
                Type genericType = ti.GetGenericTypeDefinition();
                object formatterType;
                if (FormatterMap.TryGetValue(genericType, out formatterType))
                {
                    return Activator.CreateInstance(((Type)formatterType).MakeGenericType(ti.GenericTypeArguments));
                }
            }

            else
            {
                object formatter;
                if (FormatterMap.TryGetValue(t, out formatter))
                {
                    return formatter;
                }
            }

            return null;
        }
    }
}

#endregion
